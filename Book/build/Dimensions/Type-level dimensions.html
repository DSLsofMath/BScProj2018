<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Learn You a Physics for Great Good!</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  </head>

  <body>
    <header>
      <a href="../index.html"><h1>Learn You a <span class="physics">Physics</span> for Great Good!</h1></a>
      <h1>&gt;&gt;&gt; WORK IN PROGRESS &lt;&lt;&lt;</h1>
      <h2>Dimensions / Type-level dimensions</h2>
      <nav>
	<span>[src: <a href="https://github.com/DSLsofMath/BScProj2018/blob/master/Physics/src/Dimensions/TypeLevel.lhs">Dimensions/TypeLevel.lhs</a>]</span>
        <span>Previous: <a href="../Dimensions/Testing of value-level dimensions.html">Testing of value-level dimensions</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Dimensions/Quantities.html">Quantities</a></span>
      </nav>
    </header>

    <main>
      <h1 id="type-level-dimensions">Type-level dimensions</h1>

<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Dimensions.TypeLevel</span>
    ( <span class="dt">Dim</span>(<span class="fu">..</span>)
    , <span class="dt">Mul</span>
    , <span class="dt">Div</span>
    , <span class="dt">Length</span>
    , <span class="dt">Mass</span>
    , <span class="dt">Time</span>
    , <span class="dt">Current</span>
    , <span class="dt">Temperature</span>
    , <span class="dt">Substance</span>
    , <span class="dt">Luminosity</span>
    , <span class="dt">One</span>
    ) <span class="kw">where</span></code></pre></div>
<p>We will now implement <em>type-level</em> dimensions. What is type-level? Programs (in Haskell) normally operatate on (e.g. add) values (e.g. <code>1</code> and <code>2</code>). This is on <em>value-level</em>. Now we'll do the same thing but on <em>type-level</em>, that is, perform operations on types.</p>
<p>What's the purpose of type-level dimensions? It's so we'll notice as soon as compile-time if we've written something incorrect. E.g. adding a length and an area is not allowed since they have different dimensions.</p>
<div class="figure">
<img src="Lengths_and_area.png" title="Adding lengths is OK. Adding lengths and areas is not OK." class="img-center" />

</div>
<p>This implemention is very similar to the value-level one. It would be possible to only have one implementation by using <code>Data.Proxy</code>. But it would be trickier. This way is lengthier but easier to understand.</p>
<p>To be able to do type-level programming, we'll need a nice stash of GHC-extensions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span></code></pre></div>
<p>See the end of the next chapter to read what they do.</p>
<p>We'll need to be able to operate on integers on the type-level. Instead of implementing it ourselves, we will just import the machinery so we can focus on the physics-part.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Numeric.NumType.DK.Integers</span></code></pre></div>
<p>We make a <em>kind</em> for dimensions, just like we in the previous section made <em>type</em> for dimensions. On value-level we made a <em>type</em> with <em>values</em>. Now we make a <em>kind</em> with <em>types</em>. The meaning is exactly the same, except we have moved &quot;one step up&quot;.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Dim</span> <span class="fu">=</span> <span class="dt">Dim</span> <span class="dt">TypeInt</span> <span class="co">-- Length</span>
               <span class="dt">TypeInt</span> <span class="co">-- Mass</span>
               <span class="dt">TypeInt</span> <span class="co">-- Time</span>
               <span class="dt">TypeInt</span> <span class="co">-- Current</span>
               <span class="dt">TypeInt</span> <span class="co">-- Temperature</span>
               <span class="dt">TypeInt</span> <span class="co">-- Substance</span>
               <span class="dt">TypeInt</span> <span class="co">-- Luminosity</span></code></pre></div>
<p>But <code>data Dim = ...</code> looks awfully similar to a regular data type! That's correct. But with the GHC-extension <code>DataKinds</code> this will, apart from creating a regular data type, <strong>also</strong> create a <em>kind</em>. Perhaps a less confusing syntax would've been <code>kind Dim = ...</code>. The above definition can be seen as the two following definitions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- LHS: Type</span>
<span class="co">-- RHS: Value</span>
<span class="kw">data</span> <span class="dt">Dim</span> <span class="fu">=</span> <span class="dt">Dim</span> <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- LHS: Kind</span>
<span class="co">-- RHS: Type</span>
kind <span class="dt">Dim</span> <span class="fu">=</span> <span class="dt">Dim</span> <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span>
               <span class="dt">TypeInt</span></code></pre></div>
<p>Thanks to the <code>Dim</code>-kind we can force certain types in functions to be of this kind.</p>
<p>This may sound confusing, but the point of this will become clear over time. Let's show some example <em>types</em> of the <code>Dim</code>-kind.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Length</span>      <span class="fu">=</span> <span class="ch">&#39;Dim Pos1 Zero Zero Zero Zero Zero Zero</span>
<span class="kw">type</span> <span class="dt">Mass</span>        <span class="fu">=</span> <span class="ch">&#39;Dim Zero Pos1 Zero Zero Zero Zero Zero</span>
<span class="kw">type</span> <span class="dt">Time</span>        <span class="fu">=</span> <span class="ch">&#39;Dim Zero Zero Pos1 Zero Zero Zero Zero</span>
<span class="kw">type</span> <span class="dt">Current</span>     <span class="fu">=</span> <span class="ch">&#39;Dim Zero Zero Zero Pos1 Zero Zero Zero</span>
<span class="kw">type</span> <span class="dt">Temperature</span> <span class="fu">=</span> <span class="ch">&#39;Dim Zero Zero Zero Zero Pos1 Zero Zero</span>
<span class="kw">type</span> <span class="dt">Substance</span>   <span class="fu">=</span> <span class="ch">&#39;Dim Zero Zero Zero Zero Zero Pos1 Zero</span>
<span class="kw">type</span> <span class="dt">Luminosity</span>  <span class="fu">=</span> <span class="ch">&#39;Dim Zero Zero Zero Zero Zero Zero Pos1</span></code></pre></div>
<p><code>'Dim</code> is used to distinguish between the <em>type</em> <code>Dim</code> (left-hand-side of the <code>data Dim</code> definition) and the <em>type constructor</em> <code>Dim</code> (right-hand-side of the <code>data Dim</code> definition, with <code>DataKinds</code>-perspective). <code>'Dim</code> refers to the type constructor. Both are created when using <code>DataKinds</code>.</p>
<p><code>Pos1</code>, <code>Neg1</code> and so on corresponds to <code>1</code> and <code>-1</code> in the imported package, which operates on type-level integers.</p>
<p><strong>Exercise</strong> Create types for velocity, acceleration and the scalar.</p>
<details> <summary><strong>Solution</strong></summary>
<div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Velocity</span>     <span class="fu">=</span> <span class="ch">&#39;Dim Pos1 Zero Neg1 Zero Zero Zero Zero</span>
<span class="kw">type</span> <span class="dt">Acceleration</span> <span class="fu">=</span> <span class="ch">&#39;Dim Pos1 Zero Neg2 Zero Zero Zero Zero</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">One</span> <span class="fu">=</span> <span class="ch">&#39;Dim Zero Zero Zero Zero Zero Zero Zero</span></code></pre></div>
</div>
<p></details></p>
<h2 id="multiplication-and-division">Multiplication and division</h2>
<p>Let's implement multiplication and division on the type-level. After such an operation a new dimension is created. And from the previous section we already know what the dimension should look like. To translate to Haskell-language: &quot;after such an operation a new <em>type</em> is created&quot;. How does one implement that? With <code>type family</code>! A <code>type family</code> can easiest be thought of as a function on the type-level.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Mul</span> (<span class="ot">d1 ::</span> <span class="dt">Dim</span>) (<span class="ot">d2 ::</span> <span class="dt">Dim</span>) <span class="kw">where</span>
  <span class="dt">Mul</span> (<span class="ch">&#39;Dim le1 ma1 ti1 cu1 te1 su1 lu1)</span>
      (<span class="ch">&#39;Dim le2 ma2 ti2 cu2 te2 su2 lu2) =</span>
      <span class="ch">&#39;Dim (le1+le2) (ma1+ma2) (ti1+ti2) (cu1+cu2)</span>
        (te1<span class="fu">+</span>te2) (su1<span class="fu">+</span>su2) (lu1<span class="fu">+</span>lu2)</code></pre></div>
<ul>
<li><code>type family</code> means it's a function on type-level.</li>
<li><code>Mul</code> is the name of the function.</li>
<li><code>d1 :: Dim</code> is read as &quot;the <em>type</em> <code>d1</code> has <em>kind</em> <code>Dim</code>&quot;.</li>
</ul>
<p><strong>Exercise</strong> As you would suspect, division is very similar, so why don't you try 'n implement it yourself?</p>
<details> <summary><strong>Solution</strong></summary>
<div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Div</span> (<span class="ot">d1 ::</span> <span class="dt">Dim</span>) (<span class="ot">d2 ::</span> <span class="dt">Dim</span>) <span class="kw">where</span>
  <span class="dt">Div</span> (<span class="ch">&#39;Dim le1 ma1 ti1 cu1 te1 su1 lu1)</span>
      (<span class="ch">&#39;Dim le2 ma2 ti2 cu2 te2 su2 lu2) =</span>
      <span class="ch">&#39;Dim (le1-le2) (ma1-ma2) (ti1-ti2) (cu1-cu2)</span>
        (te1<span class="fu">-</span>te2) (su1<span class="fu">-</span>su2) (lu1<span class="fu">-</span>lu2)</code></pre></div>
</div>
<p></details></p>
<p><strong>Exercise</strong> Implement a type-level function for raising a dimension to the power of some integer.</p>
<details> <summary><strong>Solution</strong></summary>
<div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Power</span> (<span class="ot">d ::</span> <span class="dt">Dim</span>) (<span class="ot">n ::</span> <span class="dt">TypeInt</span>) <span class="kw">where</span>
  <span class="dt">Power</span> (<span class="ch">&#39;Dim le ma ti cu te su lu) n =</span>
    <span class="ch">&#39;Dim (le*n) (ma*n) (ti*n) (cu*n) (te*n) (su*n) (lu*n)</span></code></pre></div>
</div>
<p></details></p>
<p>Now types for dimensions can be created by combining exisiting types, much like we did for values in the previous chapter.</p>
<p><strong>Exercise</strong> Create types for velocity, area, force and impulse.</p>
<details> <summary><strong>Solution</strong></summary>
<div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Velocity&#39;</span> <span class="fu">=</span> <span class="dt">Length</span> <span class="ot">`Div`</span> <span class="dt">Time</span>
<span class="kw">type</span> <span class="dt">Area</span>      <span class="fu">=</span> <span class="dt">Length</span> <span class="ot">`Mul`</span> <span class="dt">Length</span>
<span class="kw">type</span> <span class="dt">Force</span>     <span class="fu">=</span> <span class="dt">Mass</span>   <span class="ot">`Mul`</span> <span class="dt">Length</span>
<span class="kw">type</span> <span class="dt">Impulse</span>   <span class="fu">=</span> <span class="dt">Force</span>  <span class="ot">`Mul`</span> <span class="dt">Time</span></code></pre></div>
</div>
<p></details></p>
<p>Perhaps not very exiting so far. But just wait 'til we create a data type for quantities. Then the strenghts of type-level dimensions will be clearer.</p>

    </main>

    <footer>
      <nav>
	<span>[src: <a href="https://github.com/DSLsofMath/BScProj2018/blob/master/Physics/src/Dimensions/TypeLevel.lhs">Dimensions/TypeLevel.lhs</a>]</span>
        <span>Previous: <a href="../Dimensions/Testing of value-level dimensions.html">Testing of value-level dimensions</a></span>
        <a href="../index.html">Table of contents</a>
        <span>Next: <a href="../Dimensions/Quantities.html">Quantities</a></span>
      </nav>
      Â© Kandidatboisen (2018), GPL
    </footer>
  </body>
</html>
